\subsection{Cryptography}
\subsubsection{Introduction}
In a traditional definition of security of a cryptography scheme, one usually defines a game that characterizes the capabilities of a (hypothetical) adversary. A cryptography scheme is defined to be secure if no computationally feasible strategy allows the adversary to win the game with non-negligible probability (or advantage), for reasonable notions of feasible and negligible.
\cite{maurer2011constructive}

\paragraph{Important Elements of Cryptography}
\paragraph{Plain-text}
Original text that is immediately intelligible and can therefore be directly, without the need for deciphering.
\cite{ramet_r3.09}

\paragraph{Encrypting}
An operation that substitutes a plain text with an unintelligible text that cannot be understood by anyone who does not possess the key. Inoperable by anyone who doesn't have the key.

\paragraph{Ciphertext}
Message made unintelligible through encryption, which can only be and used only by those in possession of the encryption key.

\paragraph{Decryption}
Reverse operation of a reversible encryption, allowing an authorized in possession of the key, to restore a ciphertext in clear text.

\paragraph{Types of Cryptography}
There are two types of Cryptography: symmetric key Cryptography and asymmetric key Cryptography, both still in use today, but they have different applications due to their different qualities.

\paragraph{Symmetric Cryptography}
Symmetric Cryptography is the first one to appear, as it is a basic concept, it is as if we had a key to open a chest. In Cesar cipher is the number of shifts we will do on the alphabet to write and read the plain-text and the ciphertext respectively. The key being the most essential element in computational Cryptography, it can be almost anything that is information, a string of text, numbers, an image, etcâ€¦ That information being processed by a Cryptography algorithm it can then encode or decode Cryptographic data. Today symmetric Cryptography is used in cases where we need fast service using not much resources and not needing to share the secret key often. Such qualities interest banks for example. There are multiple symmetric cryptography algorithms such as AES, DES, 3DES, and Blowfish. All of them are based on the Feistel Network except for AES which uses a Substitution and Permutation Network.

\paragraph{Asymmetric Cryptography}
ECC (Elliptic-curve-Cryptography) Elliptic Curve Cryptography Overview Elliptic Curve Diffie Hellman A 384 bits ECC key has the same level of security as a 7680 bit RSA key, it is considered to be a Top Secret level of security by many governments such as the USA Government Shannon Information Theory and Cryptography.

\subsubsection{Advanced Encryption Standard (AES)}
AES was invented by two Belgians, Joan Daemen and Vincent Rijmen in 1998 and submitted to the National Institute of Standards and Technology (NIST) in 2001 in order to replace the DES (Data Encryption Standard) which was starting to get outdated. It uses a key of 3 different lengths 128, 192, and 256 bits.
\cite{wiki_aes}


\paragraph{Variables}\cite{nist_aes}
\begin{itemize}
    \item [$-$] \textbf{state} Intermediate result of the AES block cipher that is represented as a two-dimensional array of bytes with four rows and Nb columns.
    \item [$-$] \textbf{keys} the key schedule generated by the key expansion algorithm
\end{itemize}
\paragraph{Constants}\cite{nist_aes}
\begin{itemize}
    \item [$-$] \textbf{s\_box} A non-linear substitution table used in SUBBYTES and KEYEXPANSION to perform a one-to-one substitution of a byte value.
    \item [$-$] \textbf{inv\_s\_box} A non-linear substitution table with the inverse values of the S-box used for the decryption.
    \item [$-$] \textbf{mix\_columns} A fixed matrix used on the MIXCOLUMNS
    \item [$-$] \textbf{inv\_mix\_columns} The matrix with the hexadecimal values of mix\_columns used in INVMIXCOLUMNS
    \item [$-$] \textbf{rcon} Is the key expansion round constants used on the KEYEXPANSION
\end{itemize}
\paragraph{Functions}\cite{nist_aes}
\begin{itemize}
    \item [$-$] \textbf{SUBBYTES} Takes the state as the parameter and applies the s\_box to each byte independently.
    \item [$-$] \textbf{SHIFTROWS} Takes the state as the parameter and transforms the state shifting the last three rows with different offsets (2nd row has 1 offset, 3rd row has 2 offsets, and 4th row has 3 offsets)
    \item [$-$] \textbf{MIXCOLUMNS} Takes the state as the parameter and each column is multiplied by the Mix Columns matrix. But the multiplication is done in the Galois Field. Which means that the sum is done with the XOR operation and the multiplication is done with the AND operation.
    \item [$-$] \textbf{KEYEXPANSION} Takes the key as the parameter, the routine that generates the round keys from the key.
    \item [$-$] \textbf{ADDROUNDKEY} Takes the state and round key as the parameters and transforms the state by performing an XOR operation on the state with the round key.
    \item [$-$] \textbf{CIPHER} Takes the plain text and the key as arguments and perform the AES algorithm using the functions SUBBYTES, SHIFTROWS, MIXCOLUMNS, KEYEXPANSION and ADDROUNDKEY.
    \item [$-$] \textbf{INVCIPHER} Takes the cipher text and makes the reverse operation as CIPHER.
\end{itemize}

\paragraph{AES Algorithm}\cite{nist_aes}
\begin{algorithm}[H]
\caption{CIPHER Algorithm}
\begin{algorithmic}[1]
\Procedure{CIPHER}{$plain\_text: list[int], key: list[int]$}
    \State $state \gets 4 \times 4$ matrix of zeros
    \For{$i \in [0, 4)$}
        \For{$j \in [0, 4)$}
            \If{$i*4+j < \text{len}(plain\_text)$}
                \State $state[j][i] \gets plain\_text[i*4+j]$
            \EndIf
        \EndFor
    \EndFor
    \State $keys \gets \text{KEYEXPANSION}(key)$
    \State $state \gets \text{ADDROUNDKEY}(state, keys[0])$
    \For{$i \in [1, 10)$}
        \State $state \gets \text{SUBBYTES}(state)$
        \State $state \gets \text{SHIFTROWS}(state)$
        \State $state \gets \text{MIXCOLUMNS}(state)$
        \State $state \gets \text{ADDROUNDKEY}(state, keys[i])$
    \EndFor
    \State $state \gets \text{SUBBYTES}(state)$
    \State $state \gets \text{SHIFTROWS}(state)$
    \State $state \gets \text{ADDROUNDKEY}(state, keys[10])$
    \State \Return $[state[i][j] \text{ for } i \in [0, 4) \text{ for } j \in [0, 4)]$
\EndProcedure
\end{algorithmic}
\end{algorithm}

\paragraph{Why is AES so hard to break}
For symmetric Cryptography we have three properties that measures if a cryptography system is secure or not.
\paragraph{Confusion and Diffusion}\cite{ramet_r3.09}
Confusion is when there is no statistical property that can be deduced from the ciphertext and Diffusion is when a change on the plain text changes the majority of the ciphertext.

\paragraph*{Example of Diffusion and Confusion in AES}

\textbf{Plain-text 1:} Hello World!

\textbf{Ciphertext 1:} \\
{\small\texttt{0101111111001111111111000010100001101100110001011011001010001000\\1110101000000011000011101000100010011000110110001100011001000010}}

\textbf{Plain-text 2:} Hallo World!

\textbf{Ciphertext 2:} \\
{\small\texttt{0100011001111001011111000100101000100100010011110101001100010100\\1011001010110010110110001010010101111111101101011110011110100111}}

\paragraph*{Analysis}

As observed, changing one letter in the plain-text resulted in a completely different ciphertext. This demonstrates the \textbf{Diffusion} property of AES. Moreover, due to the significant changes in the ciphertext, it becomes challenging to deduce statistical properties from these two messages, showcasing the \textbf{Confusion} property.

\paragraph{Key robustness} 
When is hard to find or enumerate all possibilities of key.

If the algorithm has the Diffusion and the Confusion properties, the only way to find the key would be by trying every combination of key. Which means that to find the key it would be needed to try 2 to the power 128 possibilities.

\paragraph{Why is AES better than DES}
\begin{itemize}
    \item AES provides stronger security compared to DES.
    \item AES is faster and more efficient in terms of computation compared to DES.
    \item AES has been subjected to more scrutiny and analysis than DES, making it more reliable.
\end{itemize}

\subsubsection{Elliptic-curve Cryptography (ECC)}
ECC (Elliptic-curve Cryptography) is a public-key cryptography algorithm based on the algebraic structure of elliptic curves over finite fields. It offers a high level of security with relatively short key sizes compared to other public-key cryptography algorithms like RSA. Elliptic Curve Diffie-Hellman (ECDH) is a key exchange protocol based on ECC, and it provides a secure way for two parties to establish a shared secret over an insecure channel. Although ECC is more secure than RSA, a 384 bit ECC key is equivalent to a 7680 RSA key for example.

\paragraph{How does Elliptic-curve Cryptography works}\cite{pierce_ecdh}
\paragraph{Curve}
An Elliptic-curve is defined by 
\begin{equation*}
y^2 = x^3 + ax + b
\end{equation*}
where $a$ and $b$ are constants. And the curve looks like this.

\begin{figure}[H]
\begin{minipage}{0.5\textwidth}
  \centering
  \includegraphics[width=\linewidth]{images/curve.png}
  \caption{Elliptic-curve.}
  \label{fig:Elliptic curve}
\end{minipage}%
\begin{minipage}{0.5\textwidth}
An Elliptic-curve is defined by $y^2 = x^3 + ax + b$ where $a$ and $b$ are constants. This figure illustrates the general shape of an elliptic curve.
\end{minipage}
\end{figure}

\paragraph{Addition}
The addition operation consists of finding a 3rd point on the curve. In the example we see the following operation:
\begin{equation}
P + Q = R
\end{equation}
When we draw a line that passes through $P$ and $Q$ we get $-R$ and through the property of symmetry of elliptic curves, we can find $R$.

\begin{figure}[H]
\begin{minipage}{0.5\textwidth}
  \centering
  \includegraphics[width=\linewidth]{images/point_addition.png}
  \caption{Point addition in ECC.}
  \label{fig:point addition in ECC}
\end{minipage}%
\begin{minipage}{0.5\textwidth}
The addition operation consists of finding a third point on the curve. This figure illustrates the geometric interpretation of point addition in ECC.
\end{minipage}
\end{figure}

\paragraph{Multiplication}
The multiplication operation consists of adding a point $k$ times.
\begin{equation}
kP = P + P + \ldots + P 
\end{equation}
When adding a point to itself on a curve, the line drawn is the tangent to the curve at that point, $P$.

\begin{figure}[H]
\begin{minipage}{0.5\textwidth}
  \centering
  \includegraphics[width=\linewidth]{images/mult.png}
  \caption{Scalar Multiplication.}
  \label{fig:Scalar Multiplication}
\end{minipage}%
\begin{minipage}{0.5\textwidth}
The multiplication operation consists of adding a point $k$ times. This figure illustrates the concept of scalar multiplication in ECC.
\end{minipage}
\end{figure}

\paragraph{Implementation}
We will need to Implement two functions, add (make the addition of points), multiply(multiply a point).

The multiplication function will be a simple function of repeating an addition n times.
For the addition it wont be as simple.
So the algorithm will implement this logic.
\begin{enumerate}
    \item If one of the points is the point at infinity (represented as (0, 0)), then adding it to another point returns the other point.
    \item If the points are additive inverses (negatives) of each other, their sum is the point at infinity.
    \item If the points are distinct, calculate the slope of the line passing through them.
    \begin{equation}
    s = \frac{{Y_P - Y_Q}}{{X_P - X_Q}}
    \end{equation}
    \begin{equation}
    X_R = s^2 - (X_P - X_Q)
    \end{equation}
    \begin{equation}
    Y_R = s(X_P - X_R) - Y_P
    \end{equation}
    \item If the points are the same, calculate the slope of the tangent line to the curve at that point.
    \begin{equation}
    s = \frac{{3X_{P}^{2} + a}}{{2Y_{P}}}
    \end{equation}
    \begin{equation}
    X_R = s^2 - 2X_P
    \end{equation}
    \begin{equation}
    Y_R = s(X_P - X_R) - Y_P
    \end{equation}
\end{enumerate}

\begin{algorithm}[H]
\caption{Add two points on the curve}
\begin{algorithmic}[1]
\Procedure{Add}{$p, q$}
    \If{$p = (0, 0)$}
        \State \textbf{return} $q$
    \EndIf
    \If{$q = (0, 0)$}
        \State \textbf{return} $p$
    \EndIf
    \If{$p[0] = q[0]$ \textbf{and} $p[1] = -q[1]$}
        \State \textbf{return} $(0, 0)$
    \EndIf
    \If{$p \neq q$}
        \State $l \gets (q[1] - p[1]) \cdot (q[0] - p[0])^{-1} \mod p \, \% \, p$
    \Else
        \State $l \gets (3 \cdot p[0]^2 + a) \cdot (2 \cdot p[1])^{-1} \mod p \, \% \, p$
    \EndIf
    \State $x \gets (l^2 - p[0] - q[0]) \mod p \, \% \, p$
    \State $y \gets (l \cdot (p[0] - x) - p[1]) \mod p \, \% \, p$
    \State \textbf{return} $(x, y)$
\EndProcedure
\end{algorithmic}
\end{algorithm}

\paragraph{What makes ECC secure}

For a asymmetric Cryptography system the most important thing is to create a common key between two parts while not revealing their own private key, so it must be easy to calculate a public key from the private key but hard to make the reverse operation from the public key, that is called a trapdoor function.

To show how ECC works let's try a practical example:
\begin{figure}[H]
  \includegraphics[width=\linewidth]{images/expl.png}
  \caption{Practical example of ECC.}\cite{pierce_ecdh}
  \label{fig:Practical example of ECC}
\end{figure}
In this scenario, Eve, acting as the intermediary, managed to obtain some information, albeit incomplete. However, she lacks the critical data necessary to compute the private keys. The inherent complexity of elliptic curves ensures that deriving either the private key $\beta$ (Bob's private key) or the private key $\alpha$ (Alice's private key) in ECC solely from a point on the curve is highly challenging.
This is a simple example, as there are standard parameters for the curb such as sect571k1. \cite{secg2010}


\subsubsection{Cryptography and Shannon Information Theory} \cite{shannon1948mathematical}

In The Theory of Communication the encoding and decoding are operations made by the transmitter and the receiver both will be called transducers.

And according to the Theorem 9 it is not possible for the channel to transmit at an average rate greater than: $\frac{C}{H}-\epsilon$

For the AES cryptography system the limit is calculated like this:

First let's calculate the capacity C of the system.
As in ASCII we have a set of characters of length 128, let's name it A* and every character (or symbol) is coded in 7 bits they have the same time of encoding or decoding.
Let's define \textbf{z} which is theoretical time that a transducer takes to encode or decode a character
\begin{enumerate}
    \item Build the system for the calculations
        \begin{figure}[H]
          \centering
          \includegraphics[width=0.15\linewidth]{images/system.png}
          \caption{cryptosystem schema.}
          \label{fig:cryptosystem}
        \end{figure}
        The matrix defining the system above will look like:
        $\left|({128*W^{z}})-1\right| = 0$
    \item Find the determinant of the equation, in this case as the matrix is a singleton matrix, the determinant of the matrix is itself.
    \item Solve ${128*W^{z}}-1 = 0$ to find $W$
    \item Calculate the capacity $C = logW$
\end{enumerate}

Secondly, H is defined as the bits per symbol as said before:
$H = 7$

Finally calculate the maximum average rate of the channel $\frac{C}{H}$
\begin{equation}
    \frac{logW}{7}
\end{equation}